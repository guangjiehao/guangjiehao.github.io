[{"date":"2022-07-23T13:12:30.388Z","url":"/2022/07/23/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%88%86%E6%9E%90/","categories":[["undefined",""]],"content":"TCP协议C&#x2F;S模型总结(状态转移篇) 花女士曾经说过:“离家太远会忘记故乡，…..”,长时间在应用层面去做需求就会开始忽视掉一些最底层的知识和逻辑，一些自以为很简单的东西可能往往都只是浮于表面，最近开始回顾和提炼一些重要的东西，加深印象的同时希望能了解到一些新的东西吧！ 状态转移图 这里我们对TCP的11个状态进行一一分析： CLOSED : 整个流程图的起始状态和终结状态，在超时或者连接关闭的时候才会进入该状态。即TIME_WAIE状态等待2MSL后或者SYN_SENT超时，又或者服务器被动关闭后会该状态。 SYN_SENT : 客户端发起第一次握手后，客户端处于该状态；即第一个SYN发出后，客户端的状态由CLOSED状态转换到SYN_SENT状态。这里会等待服务器响应[SYN ACK]报文后，向服务器发送ACK报文，此时客户端状态由SYN状态转移到ESTABLISHED状态。如果等待超时，则连接建立失败，SYN_SENT状态直接转移为CLOSED状态。 ESTABLISHED: 客户端进入该状态后表明已经准备好做数据收发业务了。上面说到客户端在发出第三次握手信息后立即进入ESTABLISHDED状态，而服务器要在接收到这一包ACK之后才会从SYN_RECV状态进入到ESTABLISHED状态 LISTEN: 这里指的是服务器等待连接的状态。服务器经过socket,bind,listen这些函数之后就进入了该状态。开始监听客户端发送过来的连接请求。即服务器在接受到客户端发送过来第一个SYN后并向客户端发送[SYN ACK]报文后状态转移到SYN_RECV状态。 SYN_RCVD: 状态图中还描述了一种情况，当客户端在发送SYN的同时也收到服务器端的SYN的请求，即两个同时发起请求，那么客户端就会从SYN_SENT状态转化到SYN_REVD状态。 FIN_WAIT_1: 主动关闭的一方做完数据业务后，准备终止连接，在发送第一个FIN之后进入FIN_WAIT1状态等待对端的ACK,也就是所谓的第一次挥手。 FIN_WAIT_2: 主动发起断开的一方在接受到对端的ACK（第二次握手信息）之后，进入到FIN_WAIT2状态。 CLOSING: 主动方发送完FIN后就进入了FIN_WAIT1状态等待ACK，但是却没有等来ACK,反而等来了被动方的FIN报文，这说明被动方也发起了主动关闭请求，主动方回复ACK后，进入CLOSIONG的状态。 TIME_WAIT: 从上面的额状态转移图可以看出，TIME_WAIT状态是四次挥手操作最后都会经过的状态，我们分别从三个转移过程分别描述： 由CLOSING状态进入TIME_WAIT状态 也就是主被动双方同时发起关闭的状态下，当主动方接受到ACK后，进入到这个状态 由FIN_WAIT1进入TIME_WAIT状态 主动方在FIN_WAIT1状态下，正好被动方也发起了关闭请求，发送了FIN，这时客户端接到到了先前的ACK,也收到了对方的FIN,然后状态就由FIN_WAIT1转移到TIME_WAIT状态，然后发送ACK给对方。 由FIN_WAIT2状态进入TIME_WAIT状态 这个就是一般情况，主动方在完成自身发起的主动关闭连接请求后，接收到对面的FIN,回复ACK后，状态发生转移。 总结一下： section 1：主动方发送FIN请求关闭连接，这个时候FIN还没有到被动方，被动方此时也想着要关闭连接，也发了一个FIN报文 section 2：主动方发送FIN给被动方后，被动方发现没有数据要传输了，这时就将FIN和ACK报文合成一包发给主动方，这时FIN_WAIT1就直接转移到TIME_WAIT状态了 section 3：也就是最正常的一种情况，主动方发起FIN,被动方此时还在传输数据，收到FIN先回复一个ACK,这时主动方状态转移到FIN_WAIT2,等被动方数据传输完毕，发送FIN报文到主动方，主动方回ACK并进入TIME状态 CLOSE_WAIT: 服务器接收到FIN后，发送ACK给客户端并进入该状态。我们可以理解为被动关闭的一方此时正在等待上层应用发出关闭连接的指令。上层处理完数据调用close关闭连接，这个时候服务器发送FIN.然后进入LAST_ACK状态。 LAST_ACK: 被动方发起关闭请求后，即发送FIN后，就进入该状态。收到客户端返回的ACK后返回到CLOSED状态度。 以上便是TCP状态转移的所有过程。 经典问题复现Question 1 问： TIME_WAIT为什么需要等待2MSL才能变为CLOSED状态？什么是MSL?如果不想等怎么办？ 答：1.MSL:Maximum Segment Lifetime指的是报文段在网络中的最大生存时间，任何报文段在网络中存在超过这个时间都将会被丢弃，在linux下该值被定义为30s,在RTOS下被定义为60s. 2.TIME_WAIT状态：说白了就是等待足够久的时间，一方面让网络上延迟未达到的数据可以自然消失，即被网络丢弃，那么再出现在这条链路上的数据一定是新连接生成的；另一方面就是等待最后一个ACK可以被被动方接受，确保连接正确关闭。 3.如果我们不想等2MSL怎么办呢？有两个方法：方法一：设置地址和端口重用，我们配置开启socket的属性SO_REUSEPORT和SO_REUSEADDR，这个时候模组做服务器就会在TIME_WAIT阶段可以继续使用原地址端口建立新连接；方法二：设置该socket的可选参数LINGER来帮助我们在连接close后等待可选时间发送RST强制断开连接即可，但这有风险，可能导致网络中未传输完毕的数据丢失。 Question 2 问：SYN_SENT如果等待超时会回到CLOSED状态，判定超时的依据是什么？ 答：1.RTT:数据从网络一端传输出去到接收确认所需要的的时间；RTO:重传超时时间，即超过这个时间还没有接收到确认包，就需要发起重传了。 2.客户端状态SYN_SENT需要接受服务器的确认和SYN来发生状态转换，但是由于网络原因，该SYN没有被服务器收到或者模块没收到服务器数据，就会开启重传定时器，等待RTO之后重新发送SYN报文，注意RTO的时间不是固定的，它会随着重传的次数翻倍，达到次数后还没有收到服务器的[SYN ACK],那么该状态结束返回到CLOSED状态。 3.Linux下握手信息默认重传5次，报文重传次数默认15次，LWIP中默认重传次数为7次 Question 3 问：请简述一下为什么需要三次握手和四次挥手？ 答：1.在RFC 793中对于三次握手的说明大概是：用于保证可靠性和流量控制的某些状态信息：包括socket(包含IP和端口信息)；sequence number(用于保证可靠传输);window sizes(用于流量控制) 2.那么我们这里给出必须三次握手的原因：1).一个四元组确定一个唯一的连接，那么只有三次握手就可以让客户端有足够的的上下文来判断当前连接是否是历史连接，防止将历史连接初始化。2).序列号保证可靠传输，只有三次握手才能让通信双方正确交换保存序列号，达到可靠通信。 3.至于4次挥手 的原因就比较简单了：我们参考三次握手，那么至少也需要三次挥手，但是三次挥手不能解决网络中遗留的数据问题，即客户端收到ACK之后还需要等待服务器数据传输完毕之后发送FIN，那么就是将第二次过程拆分开来看，一句话就是为了保证网络中的数据都可以得到妥善处理后再关闭。 Question 4 问：如果三次握手或者四次挥手过程中的任何一包丢掉了，接下来会怎么样？ 答：1.同样先从三次握手说起：假如第一包握手信息丢失，此时客户端已经进入SYN_SENT状态，一个RTO内没有收到第二包握手信息就触发重传，5次重传后还没有收到则状态由SYN_SENT转移到CLOSED 2.假如第二包握手信息丢失：服务器此时已经进入SYN_RECVED状态，发送[SYN ACK]给客户端，报文丢失后会客户端没有收到确认触发第一次握手信息重传，同时服务器没有收到第三次握手信息触发第二包握手信息重传。同样在5次重传后状态转移为CLOSED。 3.假如第三包握手信息丢失：这个状态就比较特殊了，我们知道客户端在发送完第三包ACK之后就进入了ESTABLISH状态了，但这个时候服务器在等待这包ACK,没等到第三包握手即触发第二包重传，重传失败后发送RST断开连接。但是这期间客户端可是处于连接态的，客户端向服务器发送数据，由于全连接没有真正建立，数据就会进入不断重传的情况，直到到达数据最大重传次数后结束连接状态，由ESTABLISH转移到CLOSED状态。 4.至于4次挥手丢包情况可以参照三次握手分析，绕不过重传和状态转移。 今天就说到这吧！打游戏去！ "},{"title":"位运算的一些奇技淫巧","date":"2022-07-16T03:28:01.758Z","url":"/2022/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","categories":[["undefined",""]],"content":"位运算的一些奇技淫巧 位运算这种计算方式已经淡出我的编码习惯很久了，最近突然看见一篇推文在讲一些位运算在特殊场景下的奇妙作用，这显然勾起了阿光对于位运算的一泡浓厚的兴趣，于是我就搜集了一些位运算常用的技巧在这里和大家分享一下。 其实像这种技巧题目的话知道就行了，能做到遇到类似的情况会用就行，想要真的自己去发现这些东西还是有点难度的，就交给大佬们去做吧！ 位运算简介常见的位运算也就是以下6种： | 运算：即或运算，全0则0 &amp; 运算：即与运算，全1则1 ^ 运算：即异或运算，相同为0，不同为1 ~ 运算：即非运算，0为1,1为0 (&lt;&lt;) 运算：左移运算，高位丢弃，低位补0 (&gt;&gt;) 运算：右移运算。（无符号）低位丢弃，高位补0；（有符号）低位丢弃，高位补符号 常用的就是这6种，一般解题中也完全够用了！ 技巧介绍1.位操作实现加减乘除运算加法运算这里先从加法运算说起： 我们假设 a: 001010101b: 000101111 在无进位相加下，a^b 就可以达到相加的目的；而在只考虑进位的位的情况下，就是只考虑进位产生的值的时候，我们可以用（a&amp;b）&lt;&lt; 1,那么我们结合上面两种情况是不是可以这么想：我们将a^b的值和(a&amp;b)&lt;&lt;1的值轮番进行求 ^ 和 &amp;&lt;&lt;1 运算，直到最后&amp;&lt;&lt;1的值算为全0，这就意味着所有的进位都已经被 ^ 进结果了，那么最终的结果就是求和的值了 我们可以看见，当最后 &amp;&lt;&lt;1 的结果为0时，说明所有的进位都已经被加到结果中去了，那么该结果也就是最终的计算结果了。 这里我们用代码把它表示出来： 减法运算那么减法运算就很好理解了，我们可以认为a-b &#x3D; a+(-b)，这里就是要求得b的相反数，那么根据规则，一个数的相反数（补码）就等于反码加1，那么我们是不是可以这么写： 乘法运算假设我们要计算 a * b,那么我们就可以写成a * 2^0 * b0 + a * 2^1 * b1 + …….+ a * 2^31 * b31,其中bi为 0 或者为 1 代表整数 b 的二进制数表达中第 i 位的值。 这里我们同样举一个例子： a &#x3D; 22 &#x3D; 000010110b &#x3D; 13 &#x3D; 000001101res &#x3D; 0&#x3D; 000000000 也不知道是哪一位鬼才总结出这种神奇的算法，说实话，有这个计算的功夫，我用正常的计算方法都交卷了。除了应对一些题目外，大家了解一下就好了。 下面用代码描述一下上面的过程： 除法运算这里就不过多赘述了，由于使用的很少加上思路和乘法是一样的，大家有兴趣的可以自己下来推一下。（其实是阿光不想写了） 交换两个整数值如果有人说让你交换两个整数的值但不能额外申请第三个变量，你准备使用什么方法呢？ 那么你应该想到这种方法： 这里解释一下：首先，a &#x3D; a ^ b; 那么 b &#x3D; a ^ b &#x3D; (a ^ b) ^ b &#x3D; a,那么这里就把 a 的值成功的给了b; 第三步就是将前两步的结果带入计算： a &#x3D; (a ^ b) ^ a &#x3D; b; 交换值的目的就达到了。是不是很奇妙呢？ 判断奇偶数我觉得这个方法正是让人眼前一亮，核心思想其实就是根据数的最后一位是0还是1来做判断，那么就有： 高低位交换这个还是比较常用的，在很多客制化的协议里面，常常涉及到高低位交换的操作。假设有一个16位无符号，将其高8位和低8位进行交换： 举个例子: 00111010 01010011…. 那么高低8位进行交换就得到: 01010011 00111010 这就是完全不相同的两个数了。 从上面的操作我们可以看出，将无符号数 a &gt;&gt; 8 就可以将高8位转移到低8位，高位补0； 同时将a &lt;&lt; 8 就可以将低8位转移到高8位，低8位补0，然后将 a &gt;&gt; 8 和 a&lt;&lt; 8 尽行或操作就可以求得交换后的结果。 统计二进制中1的个数这里巧妙的用到了一个 a &amp;&#x3D; (a-1),说一下原理： a与a-1进行运算，那么每次都可以消去一个1，那么我们搞一个计数器，当把a所有的1都消去之后，返回计数器的值就可以了，非常的方便 在出现偶数次的数组中找出奇数次的数这里我们直接看一个力扣上的题目： 给定一个数组arr,其中只有一个数出现了奇数次，其他的数都是偶数次，将这个数打印出来。 其实想一下这个题目可以有很多方法都能做出来，但是题目给出的要求是时间复杂度O（N）,常规方法遍历一遍能找出来吗？我是没有想到什么好方法，这里提供一种位运算的思路： 整数n与0异或的结果是 n,整数n与整数n异或的结果是0. 我们申请一个整形变量 A0赋值为0 ,将A0与arr中的每一个数求异或，那么最后留下来的那个数就是只出现过一次的数，可以揣摩一下。 大小写转换除了上面的妙用以外，利用或运算|和空格将英文字符转化为小写 (‘a’ | ‘ ‘) &#x3D; ‘a’(‘A’ | ‘ ‘) &#x3D; ‘a’ 利用与运算 &amp; 和下划线将英文字符转化为大写 ( ‘b’ &amp; ‘ _ ‘) &#x3D; ‘B’( ‘B’ &amp; ‘ _ ‘) &#x3D; ‘B’ 利用异或操作 ^ 和空格进行英文字符大小写互换 (‘d’ ^ ‘ ‘) &#x3D; ‘D’(‘D’ ^ ‘ ‘) &#x3D; ‘d’ "},{"title":"嵌入式的几种数据校验方式","date":"2022-05-10T14:25:16.486Z","url":"/2022/05/10/qianrushi/","categories":[["undefined",""]],"content":"嵌入式的几种数据校验方式 最近在给客户适配FOTA业务的时候，遇到了一个问题，我们的模组下载完差分包之后显示数据校验不通过，但是对比了差分包和模组下载存储的文件发现是一致的，通过对比客户MCU端的验证代码以及某友商的指令集发现我们对于差分包的校验方式与友商的不太一致，我们采取的是16位和校验的方式计算文件，而客户的MCU端使用的16位异或校验来计算，这是导致文件校验失败的原因。 趁此机会，顺便总结一下我们日常对于文件校验的一些算法。发车发车…… 目录 正文 以上说到了几种嵌入式开发中比较常见的几种数据校验方式，我们从和校验开始说起吧！ 校验和 校验和是一种比较简单的校验方式，当然重要的不是有多难，而是了解它是一个什么样的计算方式，应该如何编码？假设我们需要做的是16位校验和，那么最快的方法就是使用一个int类型(32位)来存放这个数据，这样的话我们就很方便的处理了进位问题。 假设我们有一个文件名为 test.txt 存在文件系统里面.文件的内容是guangjie.hao.在计算校验和之前我们需要把这一串数据看成是16进制的序列，这就要求每两个字节组成一个组合，组合的第一个字节左移8位做高位，然后依次求和即可，如果字节长度为奇数的话则需要在数据末尾补一个0来凑成偶数。 我们按照ascii码表将其一一翻译成十六进制可得： 由于我们刚好是偶数位，所以我们不需要在末尾补0，两两一组按位组合,组合的第一个数据按位左移8位做高8位即可得到： 0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167. 然后我们做一个十六进制的加法： 0X6775+0X616E+0X676A+0X6965+0X2E68+0X6167 我们通过计算器求得他们的十进制的累加和为141697。即： 高16位：0000 0000 0000 0010 低16位：0010 1001 1000 0001 然后我们再将高16位和低16位进行求和得到：0010 1001 1000 0011。就可以得到该文件的16位校验和为：0x2983.以上便是16位校验和的计算方法，当然这个有符号的16位校验和，如果是无符号的话，那求和后的高16位会被截取掉，只留下低16位的数据位。具体的代码实现如下： 异或校验 我们了解了上面的16位校验和之后，对于16位的异或校验就好理解了，同样是上文中的test.txt文档，前面的步骤一样，两两一组，每组第一个数据左移8位得到：0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167。然后两两求异或，步骤大概是这样： 这个过程还是比较好理解的，这样一直计算下去直到最后一个数据被异或完，则整个运算过程完毕。8位的异或运算比较常见，但是过程和这个类似，区别在于数据不用左移，直接两两求异或即可！16位的异或校验和代码如下： 8位的就不细说了，网上的资料较多，可以自行查阅！ 循环冗余校验 CRC校验其实有多种不同位数的算法，不同的算法拥有不同的生成多项式，这里我们假设该算法的生成多项式为G(x) &#x3D; x^4+x^3+1(11001),要发送的数据帧多项式为F(x) &#x3D; x^7+x^5+x^4+x+1(10110011),我们应该如何求出这个数据帧的CRC校验码呢？(注：每一种位数的算法都有其固定的生成多项式，我们不可以随意更改) 我们用该算法规定的生成多项式G(x)作为模二除法(模二运算可以自行百度，比较简答)的除数，对于上面的例子，这个除数就是11001. 我们假设除数的位数有K位，那么我们就需要在要发送的数据帧后面加上(k-1)个0. 然后我们用这个新帧以模二除法的方式除以G(x),所得到的余数就是该新帧的CRC校验码. 将CRC校验码附着在原数据帧F(x)的后面,构建一个新的数据帧发送到接收端，最后将接收端将接到的数据使用模二除法除以G(x),如果没有余数，则说明数据在传输的过程中没有出错！ 模二除法的过程如下图所示： 我们根据以上的算法得到的新数据帧就是101100110100，将这个数据帧发送出去即可！ 我们以CRC-8标准生成多项式为例： CRC-8 x8+x5+x4+1 0x31（0x131） 二进制为：100110001来计算一个字节0x11的CRC_8校验码：0x11–00010001 我们使用上面的方法计算可得： 代码计算可以参考如下： 其他16位的或者32位的原理类似，都是如此计算的，网上的源码例程也比较多，大家可以自行观看！ MD5校验 即摘要算法第五版，通过特定的hash散列算法将文本信息转化为信息摘要，是一种集压缩+加密+hash算法的结合体，用于确保信息完整一致，由美国密码学家罗纳德.李维斯特设计出来的。 MD5以512位分组来处理输入的信息，每一个分组又被划分为16个32位的子分组，经过一些列处理之后，算法的输出由4个32位的分组组成，将这4个32位的分组级联之后生成一个128位的散列值。 我们的日常开发中不会让我们从底层去做这个校验，一般芯片厂商在芯片出厂前会内置好所有的接口，我们只需要自己调用就好了！我在这里就简单介绍一下这个流程： 填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得求余的结果为448，方法就是填充一个1和n个0.填充完毕之后，信息的长度就是N*512+448. 记录信息长度：用64位来记录信息长度，这64位加在填充的信息之后，这时的信息长度就变成了N*512+448+64 &#x3D; (N+1)*512。 装入标准幻数：标准幻数应该是(A&#x3D;(01234567)16,B&#x3D;(89ABCDEF)16,C&#x3D;(FEDCBA98)16,D&#x3D;(76543210)16)受大小端的影响，我们在初始化的时候一般都这样写： 接下来需要经过4轮循环运算：循环运算的次数是分组的个数(N+1),我们将每一个512字节细分为16个小组，每一个小组64位(8个字节)。这里有4个线性函数我们可以了解一下： F(X,Y,Z)&#x3D;(X&amp;Y)|((X)&amp;Z)G(X,Y,Z)&#x3D;(X&amp;Z)|(Y&amp;(Z))H(X,Y,Z)&#x3D;X^Y^ZI(X,Y,Z)&#x3D;Y^(X|(~Z)) 以及4个散列函数，mj表示消息的第j个子分组： FF(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s) GG(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s) HH(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s) II(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s) 具体的四轮运算其实就是以上几个散列函数的循环调用。具体的可以参考展锐平台的代码查看！大致的数据处理流程就是这样： MD5的应用比较广泛，涉及到文件下载过程中的一致性验证，防止文件被篡改。以及给文件产生数字指纹，通过对比文件传输前后的MD5值判断文件是否发生改更改，可以为第三方认证机构用作数字证书的生成！ 以上便是嵌入式中比较常用的一些数据校验方式，日常开发过程中根据客户的需求灵活选用即可！"}]