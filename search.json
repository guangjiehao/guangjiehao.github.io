[{"title":"ntytcp协议栈(零拷贝&柔性数组)","date":"2022-10-22T07:42:19.143Z","url":"/2022/10/22/ntytcp%E5%8D%8F%E8%AE%AE%E6%A0%88(%E9%9B%B6%E6%8B%B7%E8%B4%9D&%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84)/","categories":[["undefined",""]],"content":"ntytcp协议栈（零拷贝&amp;柔性数组）前言最近阿光在阅读一些优秀前辈的源码时，了解到了一套国产化的tcp&#x2F;ip协议栈—ntytcp协议栈，该协议栈由G站ID: wangbojing 先生开源。它是一套单线程用户态协议栈，使用epoll实现高并发,据说可以达到C10K的性能，不知道是真是假，抱着学习的态度，我们来了解一下它高性能的原因之一：零拷贝技术。以及介绍一种网络协议栈中常用的柔性数组。 零拷贝背景我们以linux操作系统的标准I&#x2F;O接口是基于数据拷贝操作的。I&#x2F;O操作会导致数据在内核空间和用户空间之间进行传输。这样做可以减少磁盘I&#x2F;O操作。但是存在的一个问题就是频繁的数据拷贝会有很大的CPU开销，限制导致操作系统传输数据效率比较的低下，尤其是在并发量很大的情况下，低下的数据传输效率将导致很大的系统性延时，造成性能降低。 零拷贝技术在并发量越来越大的情况下应运而生，他完美的解决了高并发下数据传输效率的问题。在某种程度上减少甚至避免了不必要的CPU数据拷贝的操作。 概念它是一种避免CPU进行数据拷贝的技术，可以减少用户空间和内核空间之间由于上下文切换而带来的开销；数据拷贝是一件简单而机械的任务，CPU一直被占用着去做数据拷贝是一件很浪费资源的事情。那么零拷贝技术的目标可以概括如下： 1.避免数据拷贝 避免内核缓冲区之间的数据拷贝 避免内核空间与用户空间之间的内存拷贝 用户程序可以避开操作系统直接访问硬件外设 数据传输尽量让DMA来做 2.综合目标 避免不必要的系统调用和上下文切换 需要拷贝到的数据可以先缓存起来 数据处理尽量交给硬件来做 我们来看一个传统的IO执行的流程：对于服务器来说我们下载的过程即将主机磁盘文件通过已经连接的socket发出去：核心代码如下： 传统的IO流程包括read和write的过程 大致的流程如下： 1.应用程序调用read函数，向操作系统发起IO调用，上下文从用户态切换到内核态。 2.DMA控制器把数据从磁盘读取到内核缓冲区 3.CPU把内核缓冲区数据拷贝到用户应用缓冲区，上下文从内核态切换到用户态，这个时候read函数返回 4.用户应用程序通过write函数，发起IO调用，上下文从用户态切换到内核态 5.CPU将缓冲区的数据拷贝到SOCKET缓冲区 6.DMA控制器将数据从socket拷贝到网卡设备，上下文从内核态切换到用户态，write返回。 从上面可以看出，传统的IO流程包括了4次上下文的切换，4次数据拷贝 其中内核空间主要提供进程调度，内存分配，连接硬件资源等功能；用户空间，提供给各个程序进程的空间，它不具有访问内核空间资源的权限，可以通过系统调用来完成用户空间的切换。 CPU上下文：CPU寄存器，是CPU内置的容量小，但速度极快的内存。而程序计数器，则是用来查询CPU正在执行的指令位置，或者即将执行的下一条指令的位置。他们都是CPU在运行任何任务之前，必须要依赖的环境，因此叫做CPU上下文。 虚拟内存在现代操作系统中，虚拟内存取代了物理地址，关于虚拟内存的内容阿光在之前的章节里面也有提到过，使用虚拟内存有如下两个好处： 1.虚拟内存空间远大于物理地址空间 2.多个虚拟内存可以指向同一物理地址 那么正是由于这种机制使得0拷贝的实现有了可能： DMA技术DMA即直接内存访问，他允许外部设备和内存直接进行IO数据传输，这个过程不需要CPU的参与 简单的说他就是帮助CPU转发一下IO请求以及拷贝数据。这时候CPU资源就能被释放出来去做别的事情，提高CPU的利用效率。下面我们通过一张图来看下DMA都做了那些工作： 可以从上图看出来DMA方式区别于中断方式，直接绕过CPU请求将数据拷贝到主存，减少CPU资源消耗，硬件效率可以大大提高！ 方式那么很明显我们要继续优化上述流程的话，只需要做到两点即可： 1.减少CPU上下文切换的次数 2.减少内存拷贝次数 零拷贝技术主要有以下两种实现方式： mmap+write方式 senndfile方式 mmap+writemmap 即 memeoy map 内存映射机制，我们使用mmap()来代替前面IO流程中的read(),mmap()会将内核缓冲区的数据直接映射到用户空间，该过程由DMA完成，在调用write()将数据搬运到socket缓冲区，最后socket将数据交付给网卡，整个过程减少了一次由内核到用户态的数据拷贝。 存在问题及解决方案需要注意的是，在多线程模式下，如果我们mmap了一个文件，但这个时候文件被另一个线程处理或者截断了，那么我们调用write的时候就会因为访问非法地址而导致进程被CPU杀死，导致程序崩溃！所以这就告诉我们在对mmap的文件进行操作的时候一定要加上一个锁！在操作完之后再解锁。 加锁的操作可以保证当前进程被CPU杀死之前由一个信号通知当前进程将write()返回当前写入的长度，将erron返回SUCC sendfileLinux从2.1内核版本开始就支持一个用于传输文件的系统调用接口sendfile(),该系统调用可以替代read()和write()完成一次系统调用；另外，该系统调用可以直接将内核缓冲区的数据拷贝到socket缓冲区，减少了中间用户态的一次拷贝。通过以上sendfile()就减少了整个过程中2次数据拷贝和3次的CPU上下文切换，但这些也没有实现真正意义上的0拷贝。 随着版本的迭代，在Linux 2.4内核版本到来的时候，sendfile()过程发生了如下的变化： 通过DMA将磁盘数据直接拷贝到内核缓冲区中 只将缓冲区描述符和长度拷贝到socket缓冲区，而缓冲区数据可以通过网卡的SG-DMA控制器直接拷贝到网卡缓冲区中，这样就又减少了一次数据拷贝。 该过程中全程没有CPU参与数据拷贝，都是有DMA完成，可以算是真正意义上的零拷贝技术了。 柔性数组之前在阅读ntytcp协议栈的时候发现用以数据传输的结构体中定义了一个char data[0] 这个东西我们平时编程中很少使用到，带着一些不解对这种数据结构做了一些了解： C99标准引入了柔性数组这一特性，这个柔性数组的大小可以根据程序运行中需要的大小进行更改。需要注意的是，柔性数组只能在结构体的最后一个成员进行定义，且该结构体必须最少包含一个其他数据类型的成员。例如： 柔性数组是不占用结构体的内存，也就是说sizeof(struct)不会计算柔性数组，如下： 可以看见在计算结构体占用内存的时候只计算了前两个int类型数据，并没有计算数组。 至于它为什么不占用内存，感兴趣的小伙伴可以尝试将代码汇编一下，对比一下指针数组和柔性数组： addq这一步操作翻译过来： %rax+sizeof(struct) 该结构体的末尾正好是柔性数组，由于柔性数组只代表数据的其实地址，所以这一步只拿到了地址；但是movq 则是直接操作地址里面的内容。 那么就可得，我们访问柔性数组就是在访问数组的相对地址，但是访问指针数组就是在访问相对地址里的内容。 好了我们现在假设一个场景，现在服务器要下发一包不知道多大的数据给到客户端，现在关于数据接受有三种方案： 采用定长数组缓存数据 采用指针数组缓存数据 采用柔性数组缓存数据 下面我们来看一下三个存储方式的优劣： 首先第一种情况：客户看了想打人系列，用一个定长数组去存储数据，每一次下行数据无论大小都有占用固定大小的内存来存储数据，会造成设备内存的浪费。因此这种结构在实际的开发中一般很少用到。 第二种指针数组存放：这是目前使用最普遍的一种数据类型，内存大小可以随意申请，使用完释放即可，比较节约空间；但是存在的一个问题：这种方法需要首先对结构体申请内存，其次对结构体数据域申请内存，也就是两次不连续的内存申请，这对程序猿来说是很不友好的，意味着我们需要进行两次内存释放。由于多数情况下申请的内存不会在同一个接口里面进行释放，这很容易导致内存泄漏。 经典案例就是我司某款产品在客户现场由于云端下发数据帧申请的内存在另一个线程数据入队后没有及时释放，导致和云端进行6000+次通信后内存耗尽的情况，可谓损失惨重！ 第三种柔性数组存放：相较于第二种方法，使用柔性数组可以一次性申请任意大小的内存用于存放数据，注意是一次性，也就意味着我们可以一次性释放内存，这无疑大大减少了内存泄漏的风险： 总结一下，使用柔性数组进行数据缓存的优点： 1.相比于定长数组来说节省空间和网络带宽 2.相较于指针数组来说数组本身不占用空间，且可以一次性申请内存和释放内存，降低了内存泄漏的风险，同时也降低了内存碎片产生的概率。 记得公众号看一看呀！"},{"title":"TCP协议C/S模型总结","date":"2022-07-23T13:42:50.286Z","url":"/2022/07/23/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%88%86%E6%9E%90/","categories":[["undefined",""]],"content":"TCP协议C&#x2F;S模型总结(状态转移篇) 花女士曾经说过:“离家太远会忘记故乡，…..”,长时间在应用层面去做需求就会开始忽视掉一些最底层的知识和逻辑，一些自以为很简单的东西可能往往都只是浮于表面，最近开始回顾和提炼一些重要的东西，加深印象的同时希望能了解到一些新的东西吧！ 状态转移图 这里我们对TCP的11个状态进行一一分析： CLOSED : 整个流程图的起始状态和终结状态，在超时或者连接关闭的时候才会进入该状态。即TIME_WAIE状态等待2MSL后或者SYN_SENT超时，又或者服务器被动关闭后会该状态。 SYN_SENT : 客户端发起第一次握手后，客户端处于该状态；即第一个SYN发出后，客户端的状态由CLOSED状态转换到SYN_SENT状态。这里会等待服务器响应[SYN ACK]报文后，向服务器发送ACK报文，此时客户端状态由SYN状态转移到ESTABLISHED状态。如果等待超时，则连接建立失败，SYN_SENT状态直接转移为CLOSED状态。 ESTABLISHED: 客户端进入该状态后表明已经准备好做数据收发业务了。上面说到客户端在发出第三次握手信息后立即进入ESTABLISHDED状态，而服务器要在接收到这一包ACK之后才会从SYN_RECV状态进入到ESTABLISHED状态 LISTEN: 这里指的是服务器等待连接的状态。服务器经过socket,bind,listen这些函数之后就进入了该状态。开始监听客户端发送过来的连接请求。即服务器在接受到客户端发送过来第一个SYN后并向客户端发送[SYN ACK]报文后状态转移到SYN_RECV状态。 SYN_RCVD: 状态图中还描述了一种情况，当客户端在发送SYN的同时也收到服务器端的SYN的请求，即两个同时发起请求，那么客户端就会从SYN_SENT状态转化到SYN_REVD状态。 FIN_WAIT_1: 主动关闭的一方做完数据业务后，准备终止连接，在发送第一个FIN之后进入FIN_WAIT1状态等待对端的ACK,也就是所谓的第一次挥手。 FIN_WAIT_2: 主动发起断开的一方在接受到对端的ACK（第二次握手信息）之后，进入到FIN_WAIT2状态。 CLOSING: 主动方发送完FIN后就进入了FIN_WAIT1状态等待ACK，但是却没有等来ACK,反而等来了被动方的FIN报文，这说明被动方也发起了主动关闭请求，主动方回复ACK后，进入CLOSIONG的状态。 TIME_WAIT: 从上面的额状态转移图可以看出，TIME_WAIT状态是四次挥手操作最后都会经过的状态，我们分别从三个转移过程分别描述： 由CLOSING状态进入TIME_WAIT状态 也就是主被动双方同时发起关闭的状态下，当主动方接受到ACK后，进入到这个状态 由FIN_WAIT1进入TIME_WAIT状态 主动方在FIN_WAIT1状态下，正好被动方也发起了关闭请求，发送了FIN，这时客户端接到到了先前的ACK,也收到了对方的FIN,然后状态就由FIN_WAIT1转移到TIME_WAIT状态，然后发送ACK给对方。 由FIN_WAIT2状态进入TIME_WAIT状态 这个就是一般情况，主动方在完成自身发起的主动关闭连接请求后，接收到对面的FIN,回复ACK后，状态发生转移。 总结一下： section 1：主动方发送FIN请求关闭连接，这个时候FIN还没有到被动方，被动方此时也想着要关闭连接，也发了一个FIN报文 section 2：主动方发送FIN给被动方后，被动方发现没有数据要传输了，这时就将FIN和ACK报文合成一包发给主动方，这时FIN_WAIT1就直接转移到TIME_WAIT状态了 section 3：也就是最正常的一种情况，主动方发起FIN,被动方此时还在传输数据，收到FIN先回复一个ACK,这时主动方状态转移到FIN_WAIT2,等被动方数据传输完毕，发送FIN报文到主动方，主动方回ACK并进入TIME状态 CLOSE_WAIT: 服务器接收到FIN后，发送ACK给客户端并进入该状态。我们可以理解为被动关闭的一方此时正在等待上层应用发出关闭连接的指令。上层处理完数据调用close关闭连接，这个时候服务器发送FIN.然后进入LAST_ACK状态。 LAST_ACK: 被动方发起关闭请求后，即发送FIN后，就进入该状态。收到客户端返回的ACK后返回到CLOSED状态度。 以上便是TCP状态转移的所有过程。 经典问题复现Question 1 问： TIME_WAIT为什么需要等待2MSL才能变为CLOSED状态？什么是MSL?如果不想等怎么办？ 答：1.MSL:Maximum Segment Lifetime指的是报文段在网络中的最大生存时间，任何报文段在网络中存在超过这个时间都将会被丢弃，在linux下该值被定义为30s,在RTOS下被定义为60s. 2.TIME_WAIT状态：说白了就是等待足够久的时间，一方面让网络上延迟未达到的数据可以自然消失，即被网络丢弃，那么再出现在这条链路上的数据一定是新连接生成的；另一方面就是等待最后一个ACK可以被被动方接受，确保连接正确关闭。 3.如果我们不想等2MSL怎么办呢？有两个方法：方法一：设置地址和端口重用，我们配置开启socket的属性SO_REUSEPORT和SO_REUSEADDR，这个时候模组做服务器就会在TIME_WAIT阶段可以继续使用原地址端口建立新连接；方法二：设置该socket的可选参数LINGER来帮助我们在连接close后等待可选时间发送RST强制断开连接即可，但这有风险，可能导致网络中未传输完毕的数据丢失。 Question 2 问：SYN_SENT如果等待超时会回到CLOSED状态，判定超时的依据是什么？ 答：1.RTT:数据从网络一端传输出去到接收确认所需要的的时间；RTO:重传超时时间，即超过这个时间还没有接收到确认包，就需要发起重传了。 2.客户端状态SYN_SENT需要接受服务器的确认和SYN来发生状态转换，但是由于网络原因，该SYN没有被服务器收到或者模块没收到服务器数据，就会开启重传定时器，等待RTO之后重新发送SYN报文，注意RTO的时间不是固定的，它会随着重传的次数翻倍，达到次数后还没有收到服务器的[SYN ACK],那么该状态结束返回到CLOSED状态。 3.Linux下握手信息默认重传5次，报文重传次数默认15次，LWIP中默认重传次数为7次 Question 3 问：请简述一下为什么需要三次握手和四次挥手？ 答：1.在RFC 793中对于三次握手的说明大概是：用于保证可靠性和流量控制的某些状态信息：包括socket(包含IP和端口信息)；sequence number(用于保证可靠传输);window sizes(用于流量控制) 2.那么我们这里给出必须三次握手的原因：1).一个四元组确定一个唯一的连接，那么只有三次握手就可以让客户端有足够的的上下文来判断当前连接是否是历史连接，防止将历史连接初始化。2).序列号保证可靠传输，只有三次握手才能让通信双方正确交换保存序列号，达到可靠通信。 3.至于4次挥手 的原因就比较简单了：我们参考三次握手，那么至少也需要三次挥手，但是三次挥手不能解决网络中遗留的数据问题，即客户端收到ACK之后还需要等待服务器数据传输完毕之后发送FIN，那么就是将第二次过程拆分开来看，一句话就是为了保证网络中的数据都可以得到妥善处理后再关闭。 Question 4 问：如果三次握手或者四次挥手过程中的任何一包丢掉了，接下来会怎么样？ 答：1.同样先从三次握手说起：假如第一包握手信息丢失，此时客户端已经进入SYN_SENT状态，一个RTO内没有收到第二包握手信息就触发重传，5次重传后还没有收到则状态由SYN_SENT转移到CLOSED 2.假如第二包握手信息丢失：服务器此时已经进入SYN_RECVED状态，发送[SYN ACK]给客户端，报文丢失后会客户端没有收到确认触发第一次握手信息重传，同时服务器没有收到第三次握手信息触发第二包握手信息重传。同样在5次重传后状态转移为CLOSED。 3.假如第三包握手信息丢失：这个状态就比较特殊了，我们知道客户端在发送完第三包ACK之后就进入了ESTABLISH状态了，但这个时候服务器在等待这包ACK,没等到第三包握手即触发第二包重传，重传失败后发送RST断开连接。但是这期间客户端可是处于连接态的，客户端向服务器发送数据，由于全连接没有真正建立，数据就会进入不断重传的情况，直到到达数据最大重传次数后结束连接状态，由ESTABLISH转移到CLOSED状态。 4.至于4次挥手丢包情况可以参照三次握手分析，绕不过重传和状态转移。 今天就说到这吧！打游戏去！记得公众号看一看呀！"},{"title":"位运算的一些奇技淫巧","date":"2022-07-16T03:28:01.758Z","url":"/2022/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","categories":[["undefined",""]],"content":"位运算的一些奇技淫巧 位运算这种计算方式已经淡出我的编码习惯很久了，最近突然看见一篇推文在讲一些位运算在特殊场景下的奇妙作用，这显然勾起了阿光对于位运算的一泡浓厚的兴趣，于是我就搜集了一些位运算常用的技巧在这里和大家分享一下。 其实像这种技巧题目的话知道就行了，能做到遇到类似的情况会用就行，想要真的自己去发现这些东西还是有点难度的，就交给大佬们去做吧！ 位运算简介常见的位运算也就是以下6种： | 运算：即或运算，全0则0 &amp; 运算：即与运算，全1则1 ^ 运算：即异或运算，相同为0，不同为1 ~ 运算：即非运算，0为1,1为0 (&lt;&lt;) 运算：左移运算，高位丢弃，低位补0 (&gt;&gt;) 运算：右移运算。（无符号）低位丢弃，高位补0；（有符号）低位丢弃，高位补符号 常用的就是这6种，一般解题中也完全够用了！ 技巧介绍1.位操作实现加减乘除运算加法运算这里先从加法运算说起： 我们假设 a: 001010101b: 000101111 在无进位相加下，a^b 就可以达到相加的目的；而在只考虑进位的位的情况下，就是只考虑进位产生的值的时候，我们可以用（a&amp;b）&lt;&lt; 1,那么我们结合上面两种情况是不是可以这么想：我们将a^b的值和(a&amp;b)&lt;&lt;1的值轮番进行求 ^ 和 &amp;&lt;&lt;1 运算，直到最后&amp;&lt;&lt;1的值算为全0，这就意味着所有的进位都已经被 ^ 进结果了，那么最终的结果就是求和的值了 我们可以看见，当最后 &amp;&lt;&lt;1 的结果为0时，说明所有的进位都已经被加到结果中去了，那么该结果也就是最终的计算结果了。 这里我们用代码把它表示出来： 减法运算那么减法运算就很好理解了，我们可以认为a-b &#x3D; a+(-b)，这里就是要求得b的相反数，那么根据规则，一个数的相反数（补码）就等于反码加1，那么我们是不是可以这么写： 乘法运算假设我们要计算 a * b,那么我们就可以写成a * 2^0 * b0 + a * 2^1 * b1 + …….+ a * 2^31 * b31,其中bi为 0 或者为 1 代表整数 b 的二进制数表达中第 i 位的值。 这里我们同样举一个例子： a &#x3D; 22 &#x3D; 000010110b &#x3D; 13 &#x3D; 000001101res &#x3D; 0&#x3D; 000000000 也不知道是哪一位鬼才总结出这种神奇的算法，说实话，有这个计算的功夫，我用正常的计算方法都交卷了。除了应对一些题目外，大家了解一下就好了。 下面用代码描述一下上面的过程： 除法运算这里就不过多赘述了，由于使用的很少加上思路和乘法是一样的，大家有兴趣的可以自己下来推一下。（其实是阿光不想写了） 交换两个整数值如果有人说让你交换两个整数的值但不能额外申请第三个变量，你准备使用什么方法呢？ 那么你应该想到这种方法： 这里解释一下：首先，a &#x3D; a ^ b; 那么 b &#x3D; a ^ b &#x3D; (a ^ b) ^ b &#x3D; a,那么这里就把 a 的值成功的给了b; 第三步就是将前两步的结果带入计算： a &#x3D; (a ^ b) ^ a &#x3D; b; 交换值的目的就达到了。是不是很奇妙呢？ 判断奇偶数我觉得这个方法正是让人眼前一亮，核心思想其实就是根据数的最后一位是0还是1来做判断，那么就有： 高低位交换这个还是比较常用的，在很多客制化的协议里面，常常涉及到高低位交换的操作。假设有一个16位无符号，将其高8位和低8位进行交换： 举个例子: 00111010 01010011…. 那么高低8位进行交换就得到: 01010011 00111010 这就是完全不相同的两个数了。 从上面的操作我们可以看出，将无符号数 a &gt;&gt; 8 就可以将高8位转移到低8位，高位补0； 同时将a &lt;&lt; 8 就可以将低8位转移到高8位，低8位补0，然后将 a &gt;&gt; 8 和 a&lt;&lt; 8 尽行或操作就可以求得交换后的结果。 统计二进制中1的个数这里巧妙的用到了一个 a &amp;&#x3D; (a-1),说一下原理： a与a-1进行运算，那么每次都可以消去一个1，那么我们搞一个计数器，当把a所有的1都消去之后，返回计数器的值就可以了，非常的方便 在出现偶数次的数组中找出奇数次的数这里我们直接看一个力扣上的题目： 给定一个数组arr,其中只有一个数出现了奇数次，其他的数都是偶数次，将这个数打印出来。 其实想一下这个题目可以有很多方法都能做出来，但是题目给出的要求是时间复杂度O（N）,常规方法遍历一遍能找出来吗？我是没有想到什么好方法，这里提供一种位运算的思路： 整数n与0异或的结果是 n,整数n与整数n异或的结果是0. 我们申请一个整形变量 A0赋值为0 ,将A0与arr中的每一个数求异或，那么最后留下来的那个数就是只出现过一次的数，可以揣摩一下。 大小写转换除了上面的妙用以外，利用或运算|和空格将英文字符转化为小写 (‘a’ | ‘ ‘) &#x3D; ‘a’(‘A’ | ‘ ‘) &#x3D; ‘a’ 利用与运算 &amp; 和下划线将英文字符转化为大写 ( ‘b’ &amp; ‘ _ ‘) &#x3D; ‘B’( ‘B’ &amp; ‘ _ ‘) &#x3D; ‘B’ 利用异或操作 ^ 和空格进行英文字符大小写互换 (‘d’ ^ ‘ ‘) &#x3D; ‘D’(‘D’ ^ ‘ ‘) &#x3D; ‘d’ "},{"title":"嵌入式的几种数据校验方式","date":"2022-05-10T14:25:16.486Z","url":"/2022/05/10/qianrushi/","categories":[["undefined",""]],"content":"嵌入式的几种数据校验方式 最近在给客户适配FOTA业务的时候，遇到了一个问题，我们的模组下载完差分包之后显示数据校验不通过，但是对比了差分包和模组下载存储的文件发现是一致的，通过对比客户MCU端的验证代码以及某友商的指令集发现我们对于差分包的校验方式与友商的不太一致，我们采取的是16位和校验的方式计算文件，而客户的MCU端使用的16位异或校验来计算，这是导致文件校验失败的原因。 趁此机会，顺便总结一下我们日常对于文件校验的一些算法。发车发车…… 目录 正文 以上说到了几种嵌入式开发中比较常见的几种数据校验方式，我们从和校验开始说起吧！ 校验和 校验和是一种比较简单的校验方式，当然重要的不是有多难，而是了解它是一个什么样的计算方式，应该如何编码？假设我们需要做的是16位校验和，那么最快的方法就是使用一个int类型(32位)来存放这个数据，这样的话我们就很方便的处理了进位问题。 假设我们有一个文件名为 test.txt 存在文件系统里面.文件的内容是guangjie.hao.在计算校验和之前我们需要把这一串数据看成是16进制的序列，这就要求每两个字节组成一个组合，组合的第一个字节左移8位做高位，然后依次求和即可，如果字节长度为奇数的话则需要在数据末尾补一个0来凑成偶数。 我们按照ascii码表将其一一翻译成十六进制可得： 由于我们刚好是偶数位，所以我们不需要在末尾补0，两两一组按位组合,组合的第一个数据按位左移8位做高8位即可得到： 0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167. 然后我们做一个十六进制的加法： 0X6775+0X616E+0X676A+0X6965+0X2E68+0X6167 我们通过计算器求得他们的十进制的累加和为141697。即： 高16位：0000 0000 0000 0010 低16位：0010 1001 1000 0001 然后我们再将高16位和低16位进行求和得到：0010 1001 1000 0011。就可以得到该文件的16位校验和为：0x2983.以上便是16位校验和的计算方法，当然这个有符号的16位校验和，如果是无符号的话，那求和后的高16位会被截取掉，只留下低16位的数据位。具体的代码实现如下： 异或校验 我们了解了上面的16位校验和之后，对于16位的异或校验就好理解了，同样是上文中的test.txt文档，前面的步骤一样，两两一组，每组第一个数据左移8位得到：0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167。然后两两求异或，步骤大概是这样： 这个过程还是比较好理解的，这样一直计算下去直到最后一个数据被异或完，则整个运算过程完毕。8位的异或运算比较常见，但是过程和这个类似，区别在于数据不用左移，直接两两求异或即可！16位的异或校验和代码如下： 8位的就不细说了，网上的资料较多，可以自行查阅！ 循环冗余校验 CRC校验其实有多种不同位数的算法，不同的算法拥有不同的生成多项式，这里我们假设该算法的生成多项式为G(x) &#x3D; x^4+x^3+1(11001),要发送的数据帧多项式为F(x) &#x3D; x^7+x^5+x^4+x+1(10110011),我们应该如何求出这个数据帧的CRC校验码呢？(注：每一种位数的算法都有其固定的生成多项式，我们不可以随意更改) 我们用该算法规定的生成多项式G(x)作为模二除法(模二运算可以自行百度，比较简答)的除数，对于上面的例子，这个除数就是11001. 我们假设除数的位数有K位，那么我们就需要在要发送的数据帧后面加上(k-1)个0. 然后我们用这个新帧以模二除法的方式除以G(x),所得到的余数就是该新帧的CRC校验码. 将CRC校验码附着在原数据帧F(x)的后面,构建一个新的数据帧发送到接收端，最后将接收端将接到的数据使用模二除法除以G(x),如果没有余数，则说明数据在传输的过程中没有出错！ 模二除法的过程如下图所示： 我们根据以上的算法得到的新数据帧就是101100110100，将这个数据帧发送出去即可！ 我们以CRC-8标准生成多项式为例： CRC-8 x8+x5+x4+1 0x31（0x131） 二进制为：100110001来计算一个字节0x11的CRC_8校验码：0x11–00010001 我们使用上面的方法计算可得： 代码计算可以参考如下： 其他16位的或者32位的原理类似，都是如此计算的，网上的源码例程也比较多，大家可以自行观看！ MD5校验 即摘要算法第五版，通过特定的hash散列算法将文本信息转化为信息摘要，是一种集压缩+加密+hash算法的结合体，用于确保信息完整一致，由美国密码学家罗纳德.李维斯特设计出来的。 MD5以512位分组来处理输入的信息，每一个分组又被划分为16个32位的子分组，经过一些列处理之后，算法的输出由4个32位的分组组成，将这4个32位的分组级联之后生成一个128位的散列值。 我们的日常开发中不会让我们从底层去做这个校验，一般芯片厂商在芯片出厂前会内置好所有的接口，我们只需要自己调用就好了！我在这里就简单介绍一下这个流程： 填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得求余的结果为448，方法就是填充一个1和n个0.填充完毕之后，信息的长度就是N*512+448. 记录信息长度：用64位来记录信息长度，这64位加在填充的信息之后，这时的信息长度就变成了N*512+448+64 &#x3D; (N+1)*512。 装入标准幻数：标准幻数应该是(A&#x3D;(01234567)16,B&#x3D;(89ABCDEF)16,C&#x3D;(FEDCBA98)16,D&#x3D;(76543210)16)受大小端的影响，我们在初始化的时候一般都这样写： 接下来需要经过4轮循环运算：循环运算的次数是分组的个数(N+1),我们将每一个512字节细分为16个小组，每一个小组64位(8个字节)。这里有4个线性函数我们可以了解一下： F(X,Y,Z)&#x3D;(X&amp;Y)|((X)&amp;Z)G(X,Y,Z)&#x3D;(X&amp;Z)|(Y&amp;(Z))H(X,Y,Z)&#x3D;X^Y^ZI(X,Y,Z)&#x3D;Y^(X|(~Z)) 以及4个散列函数，mj表示消息的第j个子分组： FF(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s) GG(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s) HH(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s) II(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s) 具体的四轮运算其实就是以上几个散列函数的循环调用。具体的可以参考展锐平台的代码查看！大致的数据处理流程就是这样： MD5的应用比较广泛，涉及到文件下载过程中的一致性验证，防止文件被篡改。以及给文件产生数字指纹，通过对比文件传输前后的MD5值判断文件是否发生改更改，可以为第三方认证机构用作数字证书的生成！ 以上便是嵌入式中比较常用的一些数据校验方式，日常开发过程中根据客户的需求灵活选用即可！"}]