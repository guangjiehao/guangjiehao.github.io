[{"title":"位运算的一些奇技淫巧","date":"2022-07-16T03:28:01.758Z","url":"/2022/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","categories":[["undefined",""]],"content":"位运算的一些奇技淫巧 位运算这种计算方式已经淡出我的编码习惯很久了，最近突然看见一篇推文在讲一些位运算在特殊场景下的奇妙作用，这显然勾起了阿光对于位运算的一泡浓厚的兴趣，于是我就搜集了一些位运算常用的技巧在这里和大家分享一下。 其实像这种技巧题目的话知道就行了，能做到遇到类似的情况会用就行，想要真的自己去发现这些东西还是有点难度的，就交给大佬们去做吧！ 位运算简介常见的位运算也就是以下6种： | 运算：即或运算，全0则0 &amp; 运算：即与运算，全1则1 ^ 运算：即异或运算，相同为0，不同为1 ~ 运算：即非运算，0为1,1为0 (&lt;&lt;) 运算：左移运算，高位丢弃，低位补0 (&gt;&gt;) 运算：右移运算。（无符号）低位丢弃，高位补0；（有符号）低位丢弃，高位补符号 常用的就是这6种，一般解题中也完全够用了！ 技巧介绍1.位操作实现加减乘除运算加法运算这里先从加法运算说起： 我们假设 a: 001010101b: 000101111 在无进位相加下，a^b 就可以达到相加的目的；而在只考虑进位的位的情况下，就是只考虑进位产生的值的时候，我们可以用（a&amp;b）&lt;&lt; 1,那么我们结合上面两种情况是不是可以这么想：我们将a^b的值和(a&amp;b)&lt;&lt;1的值轮番进行求 ^ 和 &amp;&lt;&lt;1 运算，直到最后&amp;&lt;&lt;1的值算为全0，这就意味着所有的进位都已经被 ^ 进结果了，那么最终的结果就是求和的值了 我们可以看见，当最后 &amp;&lt;&lt;1 的结果为0时，说明所有的进位都已经被加到结果中去了，那么该结果也就是最终的计算结果了。 这里我们用代码把它表示出来： 减法运算那么减法运算就很好理解了，我们可以认为a-b &#x3D; a+(-b)，这里就是要求得b的相反数，那么根据规则，一个数的相反数（补码）就等于反码加1，那么我们是不是可以这么写： 乘法运算假设我们要计算 a * b,那么我们就可以写成a * 2^0 * b0 + a * 2^1 * b1 + …….+ a * 2^31 * b31,其中bi为 0 或者为 1 代表整数 b 的二进制数表达中第 i 位的值。 这里我们同样举一个例子： a &#x3D; 22 &#x3D; 000010110b &#x3D; 13 &#x3D; 000001101res &#x3D; 0&#x3D; 000000000 也不知道是哪一位鬼才总结出这种神奇的算法，说实话，有这个计算的功夫，我用正常的计算方法都交卷了。除了应对一些题目外，大家了解一下就好了。 下面用代码描述一下上面的过程： 除法运算这里就不过多赘述了，由于使用的很少加上思路和乘法是一样的，大家有兴趣的可以自己下来推一下。（其实是阿光不想写了） 交换两个整数值如果有人说让你交换两个整数的值但不能额外申请第三个变量，你准备使用什么方法呢？ 那么你应该想到这种方法： 这里解释一下：首先，a &#x3D; a ^ b; 那么 b &#x3D; a ^ b &#x3D; (a ^ b) ^ b &#x3D; a,那么这里就把 a 的值成功的给了b; 第三步就是将前两步的结果带入计算： a &#x3D; (a ^ b) ^ a &#x3D; b; 交换值的目的就达到了。是不是很奇妙呢？ 判断奇偶数我觉得这个方法正是让人眼前一亮，核心思想其实就是根据数的最后一位是0还是1来做判断，那么就有： 高低位交换这个还是比较常用的，在很多客制化的协议里面，常常涉及到高低位交换的操作。假设有一个16位无符号，将其高8位和低8位进行交换： 举个例子: 00111010 01010011…. 那么高低8位进行交换就得到: 01010011 00111010 这就是完全不相同的两个数了。 从上面的操作我们可以看出，将无符号数 a &gt;&gt; 8 就可以将高8位转移到低8位，高位补0； 同时将a &lt;&lt; 8 就可以将低8位转移到高8位，低8位补0，然后将 a &gt;&gt; 8 和 a&lt;&lt; 8 尽行或操作就可以求得交换后的结果。 统计二进制中1的个数这里巧妙的用到了一个 a &amp;&#x3D; (a-1),说一下原理： a与a-1进行运算，那么每次都可以消去一个1，那么我们搞一个计数器，当把a所有的1都消去之后，返回计数器的值就可以了，非常的方便 在出现偶数次的数组中找出奇数次的数这里我们直接看一个力扣上的题目： 给定一个数组arr,其中只有一个数出现了奇数次，其他的数都是偶数次，将这个数打印出来。 其实想一下这个题目可以有很多方法都能做出来，但是题目给出的要求是时间复杂度O（N）,常规方法遍历一遍能找出来吗？我是没有想到什么好方法，这里提供一种位运算的思路： 整数n与0异或的结果是 n,整数n与整数n异或的结果是0. 我们申请一个整形变量 A0赋值为0 ,将A0与arr中的每一个数求异或，那么最后留下来的那个数就是只出现过一次的数，可以揣摩一下。 大小写转换除了上面的妙用以外，利用或运算|和空格将英文字符转化为小写 (‘a’ | ‘ ‘) &#x3D; ‘a’(‘A’ | ‘ ‘) &#x3D; ‘a’ 利用与运算 &amp; 和下划线将英文字符转化为大写 ( ‘b’ &amp; ‘ _ ‘) &#x3D; ‘B’( ‘B’ &amp; ‘ _ ‘) &#x3D; ‘B’ 利用异或操作 ^ 和空格进行英文字符大小写互换 (‘d’ ^ ‘ ‘) &#x3D; ‘D’(‘D’ ^ ‘ ‘) &#x3D; ‘d’ "},{"title":"嵌入式的几种数据校验方式","date":"2022-05-10T14:25:16.486Z","url":"/2022/05/10/qianrushi/","categories":[["undefined",""]],"content":"嵌入式的几种数据校验方式 最近在给客户适配FOTA业务的时候，遇到了一个问题，我们的模组下载完差分包之后显示数据校验不通过，但是对比了差分包和模组下载存储的文件发现是一致的，通过对比客户MCU端的验证代码以及某友商的指令集发现我们对于差分包的校验方式与友商的不太一致，我们采取的是16位和校验的方式计算文件，而客户的MCU端使用的16位异或校验来计算，这是导致文件校验失败的原因。 趁此机会，顺便总结一下我们日常对于文件校验的一些算法。发车发车…… 目录 正文 以上说到了几种嵌入式开发中比较常见的几种数据校验方式，我们从和校验开始说起吧！ 校验和 校验和是一种比较简单的校验方式，当然重要的不是有多难，而是了解它是一个什么样的计算方式，应该如何编码？假设我们需要做的是16位校验和，那么最快的方法就是使用一个int类型(32位)来存放这个数据，这样的话我们就很方便的处理了进位问题。 假设我们有一个文件名为 test.txt 存在文件系统里面.文件的内容是guangjie.hao.在计算校验和之前我们需要把这一串数据看成是16进制的序列，这就要求每两个字节组成一个组合，组合的第一个字节左移8位做高位，然后依次求和即可，如果字节长度为奇数的话则需要在数据末尾补一个0来凑成偶数。 我们按照ascii码表将其一一翻译成十六进制可得： 由于我们刚好是偶数位，所以我们不需要在末尾补0，两两一组按位组合,组合的第一个数据按位左移8位做高8位即可得到： 0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167. 然后我们做一个十六进制的加法： 0X6775+0X616E+0X676A+0X6965+0X2E68+0X6167 我们通过计算器求得他们的十进制的累加和为141697。即： 高16位：0000 0000 0000 0010 低16位：0010 1001 1000 0001 然后我们再将高16位和低16位进行求和得到：0010 1001 1000 0011。就可以得到该文件的16位校验和为：0x2983.以上便是16位校验和的计算方法，当然这个有符号的16位校验和，如果是无符号的话，那求和后的高16位会被截取掉，只留下低16位的数据位。具体的代码实现如下： 异或校验 我们了解了上面的16位校验和之后，对于16位的异或校验就好理解了，同样是上文中的test.txt文档，前面的步骤一样，两两一组，每组第一个数据左移8位得到：0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167。然后两两求异或，步骤大概是这样： 这个过程还是比较好理解的，这样一直计算下去直到最后一个数据被异或完，则整个运算过程完毕。8位的异或运算比较常见，但是过程和这个类似，区别在于数据不用左移，直接两两求异或即可！16位的异或校验和代码如下： 8位的就不细说了，网上的资料较多，可以自行查阅！ 循环冗余校验 CRC校验其实有多种不同位数的算法，不同的算法拥有不同的生成多项式，这里我们假设该算法的生成多项式为G(x) &#x3D; x^4+x^3+1(11001),要发送的数据帧多项式为F(x) &#x3D; x^7+x^5+x^4+x+1(10110011),我们应该如何求出这个数据帧的CRC校验码呢？(注：每一种位数的算法都有其固定的生成多项式，我们不可以随意更改) 我们用该算法规定的生成多项式G(x)作为模二除法(模二运算可以自行百度，比较简答)的除数，对于上面的例子，这个除数就是11001. 我们假设除数的位数有K位，那么我们就需要在要发送的数据帧后面加上(k-1)个0. 然后我们用这个新帧以模二除法的方式除以G(x),所得到的余数就是该新帧的CRC校验码. 将CRC校验码附着在原数据帧F(x)的后面,构建一个新的数据帧发送到接收端，最后将接收端将接到的数据使用模二除法除以G(x),如果没有余数，则说明数据在传输的过程中没有出错！ 模二除法的过程如下图所示： 我们根据以上的算法得到的新数据帧就是101100110100，将这个数据帧发送出去即可！ 我们以CRC-8标准生成多项式为例： CRC-8 x8+x5+x4+1 0x31（0x131） 二进制为：100110001来计算一个字节0x11的CRC_8校验码：0x11–00010001 我们使用上面的方法计算可得： 代码计算可以参考如下： 其他16位的或者32位的原理类似，都是如此计算的，网上的源码例程也比较多，大家可以自行观看！ MD5校验 即摘要算法第五版，通过特定的hash散列算法将文本信息转化为信息摘要，是一种集压缩+加密+hash算法的结合体，用于确保信息完整一致，由美国密码学家罗纳德.李维斯特设计出来的。 MD5以512位分组来处理输入的信息，每一个分组又被划分为16个32位的子分组，经过一些列处理之后，算法的输出由4个32位的分组组成，将这4个32位的分组级联之后生成一个128位的散列值。 我们的日常开发中不会让我们从底层去做这个校验，一般芯片厂商在芯片出厂前会内置好所有的接口，我们只需要自己调用就好了！我在这里就简单介绍一下这个流程： 填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得求余的结果为448，方法就是填充一个1和n个0.填充完毕之后，信息的长度就是N*512+448. 记录信息长度：用64位来记录信息长度，这64位加在填充的信息之后，这时的信息长度就变成了N*512+448+64 &#x3D; (N+1)*512。 装入标准幻数：标准幻数应该是(A&#x3D;(01234567)16,B&#x3D;(89ABCDEF)16,C&#x3D;(FEDCBA98)16,D&#x3D;(76543210)16)受大小端的影响，我们在初始化的时候一般都这样写： 接下来需要经过4轮循环运算：循环运算的次数是分组的个数(N+1),我们将每一个512字节细分为16个小组，每一个小组64位(8个字节)。这里有4个线性函数我们可以了解一下： F(X,Y,Z)&#x3D;(X&amp;Y)|((X)&amp;Z)G(X,Y,Z)&#x3D;(X&amp;Z)|(Y&amp;(Z))H(X,Y,Z)&#x3D;X^Y^ZI(X,Y,Z)&#x3D;Y^(X|(~Z)) 以及4个散列函数，mj表示消息的第j个子分组： FF(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s) GG(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s) HH(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s) II(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s) 具体的四轮运算其实就是以上几个散列函数的循环调用。具体的可以参考展锐平台的代码查看！大致的数据处理流程就是这样： MD5的应用比较广泛，涉及到文件下载过程中的一致性验证，防止文件被篡改。以及给文件产生数字指纹，通过对比文件传输前后的MD5值判断文件是否发生改更改，可以为第三方认证机构用作数字证书的生成！ 以上便是嵌入式中比较常用的一些数据校验方式，日常开发过程中根据客户的需求灵活选用即可！"},{"title":"Hello World","date":"2022-05-08T04:46:45.944Z","url":"/2022/05/08/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites $ 我的名字郝光杰，请多多关照！！！More info: Deployment"}]