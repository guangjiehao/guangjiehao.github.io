[{"title":"嵌入式的几种数据校验方式","date":"2022-05-10T14:25:16.486Z","url":"/2022/05/10/qianrushi/","categories":[["undefined",""]],"content":"嵌入式的几种数据校验方式 最近在给客户适配FOTA业务的时候，遇到了一个问题，我们的模组下载完差分包之后显示数据校验不通过，但是对比了差分包和模组下载存储的文件发现是一致的，通过对比客户MCU端的验证代码以及某友商的指令集发现我们对于差分包的校验方式与友商的不太一致，我们采取的是16位和校验的方式计算文件，而客户的MCU端使用的16位异或校验来计算，这是导致文件校验失败的原因。 趁此机会，顺便总结一下我们日常对于文件校验的一些算法。发车发车…… 目录 正文 以上说到了几种嵌入式开发中比较常见的几种数据校验方式，我们从和校验开始说起吧！ 校验和 校验和是一种比较简单的校验方式，当然重要的不是有多难，而是了解它是一个什么样的计算方式，应该如何编码？假设我们需要做的是16位校验和，那么最快的方法就是使用一个int类型(32位)来存放这个数据，这样的话我们就很方便的处理了进位问题。 假设我们有一个文件名为 test.txt 存在文件系统里面.文件的内容是guangjie.hao.在计算校验和之前我们需要把这一串数据看成是16进制的序列，这就要求每两个字节组成一个组合，组合的第一个字节左移8位做高位，然后依次求和即可，如果字节长度为奇数的话则需要在数据末尾补一个0来凑成偶数。 我们按照ascii码表将其一一翻译成十六进制可得： 由于我们刚好是偶数位，所以我们不需要在末尾补0，两两一组按位组合,组合的第一个数据按位左移8位做高8位即可得到： 0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167. 然后我们做一个十六进制的加法： 0X6775+0X616E+0X676A+0X6965+0X2E68+0X6167 我们通过计算器求得他们的十进制的累加和为141697。即： 高16位：0000 0000 0000 0010 低16位：0010 1001 1000 0001 然后我们再将高16位和低16位进行求和得到：0010 1001 1000 0011。就可以得到该文件的16位校验和为：0x2983.以上便是16位校验和的计算方法，当然这个有符号的16位校验和，如果是无符号的话，那求和后的高16位会被截取掉，只留下低16位的数据位。具体的代码实现如下： 异或校验 我们了解了上面的16位校验和之后，对于16位的异或校验就好理解了，同样是上文中的test.txt文档，前面的步骤一样，两两一组，每组第一个数据左移8位得到：0X6775,0X616E,0X676A,0X6965,0X2E68,0X6167。然后两两求异或，步骤大概是这样： 这个过程还是比较好理解的，这样一直计算下去直到最后一个数据被异或完，则整个运算过程完毕。8位的异或运算比较常见，但是过程和这个类似，区别在于数据不用左移，直接两两求异或即可！16位的异或校验和代码如下： 8位的就不细说了，网上的资料较多，可以自行查阅！ 循环冗余校验 CRC校验其实有多种不同位数的算法，不同的算法拥有不同的生成多项式，这里我们假设该算法的生成多项式为G(x) &#x3D; x^4+x^3+1(11001),要发送的数据帧多项式为F(x) &#x3D; x^7+x^5+x^4+x+1(10110011),我们应该如何求出这个数据帧的CRC校验码呢？(注：每一种位数的算法都有其固定的生成多项式，我们不可以随意更改) 我们用该算法规定的生成多项式G(x)作为模二除法(模二运算可以自行百度，比较简答)的除数，对于上面的例子，这个除数就是11001. 我们假设除数的位数有K位，那么我们就需要在要发送的数据帧后面加上(k-1)个0. 然后我们用这个新帧以模二除法的方式除以G(x),所得到的余数就是该新帧的CRC校验码. 将CRC校验码附着在原数据帧F(x)的后面,构建一个新的数据帧发送到接收端，最后将接收端将接到的数据使用模二除法除以G(x),如果没有余数，则说明数据在传输的过程中没有出错！ 模二除法的过程如下图所示： 我们根据以上的算法得到的新数据帧就是101100110100，将这个数据帧发送出去即可！ 我们以CRC-8标准生成多项式为例： CRC-8 x8+x5+x4+1 0x31（0x131） 二进制为：100110001来计算一个字节0x11的CRC_8校验码：0x11–00010001 我们使用上面的方法计算可得： 代码计算可以参考如下： 其他16位的或者32位的原理类似，都是如此计算的，网上的源码例程也比较多，大家可以自行观看！ MD5校验 即摘要算法第五版，通过特定的hash散列算法将文本信息转化为信息摘要，是一种集压缩+加密+hash算法的结合体，用于确保信息完整一致，由美国密码学家罗纳德.李维斯特设计出来的。 MD5以512位分组来处理输入的信息，每一个分组又被划分为16个32位的子分组，经过一些列处理之后，算法的输出由4个32位的分组组成，将这4个32位的分组级联之后生成一个128位的散列值。 我们的日常开发中不会让我们从底层去做这个校验，一般芯片厂商在芯片出厂前会内置好所有的接口，我们只需要自己调用就好了！我在这里就简单介绍一下这个流程： 填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得求余的结果为448，方法就是填充一个1和n个0.填充完毕之后，信息的长度就是N*512+448. 记录信息长度：用64位来记录信息长度，这64位加在填充的信息之后，这时的信息长度就变成了N*512+448+64 &#x3D; (N+1)*512。 装入标准幻数：标准幻数应该是(A&#x3D;(01234567)16,B&#x3D;(89ABCDEF)16,C&#x3D;(FEDCBA98)16,D&#x3D;(76543210)16)受大小端的影响，我们在初始化的时候一般都这样写： 接下来需要经过4轮循环运算：循环运算的次数是分组的个数(N+1),我们将每一个512字节细分为16个小组，每一个小组64位(8个字节)。这里有4个线性函数我们可以了解一下： F(X,Y,Z)&#x3D;(X&amp;Y)|((X)&amp;Z)G(X,Y,Z)&#x3D;(X&amp;Z)|(Y&amp;(Z))H(X,Y,Z)&#x3D;X^Y^ZI(X,Y,Z)&#x3D;Y^(X|(~Z)) 以及4个散列函数，mj表示消息的第j个子分组： FF(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s) GG(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s) HH(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s) II(a,b,c,d,Mj,s,ti)表示a&#x3D;b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s) 具体的四轮运算其实就是以上几个散列函数的循环调用。具体的可以参考展锐平台的代码查看！大致的数据处理流程就是这样： MD5的应用比较广泛，涉及到文件下载过程中的一致性验证，防止文件被篡改。以及给文件产生数字指纹，通过对比文件传输前后的MD5值判断文件是否发生改更改，可以为第三方认证机构用作数字证书的生成！ 以上便是嵌入式中比较常用的一些数据校验方式，日常开发过程中根据客户的需求灵活选用即可！"},{"title":"Hello World","date":"2022-05-08T04:46:45.944Z","url":"/2022/05/08/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites $ 我的名字郝光杰，请多多关照！！！More info: Deployment"}]